package gr.codebb.arcadeflex.v067.mame;

public class cpuintrfH {
//TODO /*************************************
//TODO  *
//TODO  *	Enum listing all the CPUs
//TODO  *
//TODO  *************************************/
//TODO 
//TODO /* the following list is automatically generated by makelist.pl - don't edit manually! */

    public static final int CPU_DUMMY = 0;
    public static final int CPU_Z80 = 1;
//TODO #endif
//TODO #if (HAS_Z180)
//TODO 	CPU_Z180,
//TODO #endif
//TODO #if (HAS_8080)
//TODO 	CPU_8080,
//TODO #endif
//TODO #if (HAS_8085A)
//TODO 	CPU_8085A,
//TODO #endif
//TODO #if (HAS_M6502)
//TODO 	CPU_M6502,
//TODO #endif
//TODO #if (HAS_M65C02)
//TODO 	CPU_M65C02,
//TODO #endif
//TODO #if (HAS_M65SC02)
//TODO 	CPU_M65SC02,
//TODO #endif
//TODO #if (HAS_M65CE02)
//TODO 	CPU_M65CE02,
//TODO #endif
//TODO #if (HAS_M6509)
//TODO 	CPU_M6509,
//TODO #endif
//TODO #if (HAS_M6510)
//TODO 	CPU_M6510,
//TODO #endif
//TODO #if (HAS_M6510T)
//TODO 	CPU_M6510T,
//TODO #endif
//TODO #if (HAS_M7501)
//TODO 	CPU_M7501,
//TODO #endif
//TODO #if (HAS_M8502)
//TODO 	CPU_M8502,
//TODO #endif
//TODO #if (HAS_N2A03)
//TODO 	CPU_N2A03,
//TODO #endif
//TODO #if (HAS_DECO16)
//TODO 	CPU_DECO16,
//TODO #endif
//TODO #if (HAS_M4510)
//TODO 	CPU_M4510,
//TODO #endif
//TODO #if (HAS_H6280)
//TODO 	CPU_H6280,
//TODO #endif
//TODO #if (HAS_I86)
//TODO 	CPU_I86,
//TODO #endif
//TODO #if (HAS_I88)
//TODO 	CPU_I88,
//TODO #endif
//TODO #if (HAS_I186)
//TODO 	CPU_I186,
//TODO #endif
//TODO #if (HAS_I188)
//TODO 	CPU_I188,
//TODO #endif
//TODO #if (HAS_I286)
//TODO 	CPU_I286,
//TODO #endif
//TODO #if (HAS_V20)
//TODO 	CPU_V20,
//TODO #endif
//TODO #if (HAS_V30)
//TODO 	CPU_V30,
//TODO #endif
//TODO #if (HAS_V33)
//TODO 	CPU_V33,
//TODO #endif
//TODO #if (HAS_V60)
//TODO 	CPU_V60,
//TODO #endif
//TODO #if (HAS_V70)
//TODO 	CPU_V70,
//TODO #endif
//TODO #if (HAS_I8035)
//TODO 	CPU_I8035,
//TODO #endif
//TODO #if (HAS_I8039)
//TODO 	CPU_I8039,
//TODO #endif
//TODO #if (HAS_I8048)
//TODO 	CPU_I8048,
//TODO #endif
//TODO #if (HAS_N7751)
//TODO 	CPU_N7751,
//TODO #endif
//TODO #if (HAS_I8X41)
//TODO 	CPU_I8X41,
//TODO #endif
//TODO #if (HAS_M6800)
//TODO 	CPU_M6800,
//TODO #endif
//TODO #if (HAS_M6801)
//TODO 	CPU_M6801,
//TODO #endif
//TODO #if (HAS_M6802)
//TODO 	CPU_M6802,
//TODO #endif
//TODO #if (HAS_M6803)
//TODO 	CPU_M6803,
//TODO #endif
//TODO #if (HAS_M6808)
//TODO 	CPU_M6808,
//TODO #endif
//TODO #if (HAS_HD63701)
//TODO 	CPU_HD63701,
//TODO #endif
//TODO #if (HAS_NSC8105)
//TODO 	CPU_NSC8105,
//TODO #endif
//TODO #if (HAS_M6805)
//TODO 	CPU_M6805,
//TODO #endif
//TODO #if (HAS_M68705)
//TODO 	CPU_M68705,
//TODO #endif
//TODO #if (HAS_HD63705)
//TODO 	CPU_HD63705,
//TODO #endif
//TODO #if (HAS_HD6309)
//TODO 	CPU_HD6309,
//TODO #endif
//TODO #if (HAS_M6809)
//TODO 	CPU_M6809,
//TODO #endif
//TODO #if (HAS_KONAMI)
//TODO 	CPU_KONAMI,
//TODO #endif
//TODO #if (HAS_M68000)
//TODO 	CPU_M68000,
//TODO #endif
//TODO #if (HAS_M68010)
//TODO 	CPU_M68010,
//TODO #endif
//TODO #if (HAS_M68EC020)
//TODO 	CPU_M68EC020,
//TODO #endif
//TODO #if (HAS_M68020)
//TODO 	CPU_M68020,
//TODO #endif
//TODO #if (HAS_T11)
//TODO 	CPU_T11,
//TODO #endif
//TODO #if (HAS_S2650)
//TODO 	CPU_S2650,
//TODO #endif
//TODO #if (HAS_TMS34010)
//TODO 	CPU_TMS34010,
//TODO #endif
//TODO #if (HAS_TMS34020)
//TODO 	CPU_TMS34020,
//TODO #endif
//TODO #if (HAS_TI990_10)
//TODO 	CPU_TI990_10,
//TODO #endif
//TODO #if (HAS_TMS9900)
//TODO 	CPU_TMS9900,
//TODO #endif
//TODO #if (HAS_TMS9940)
//TODO 	CPU_TMS9940,
//TODO #endif
//TODO #if (HAS_TMS9980)
//TODO 	CPU_TMS9980,
//TODO #endif
//TODO #if (HAS_TMS9985)
//TODO 	CPU_TMS9985,
//TODO #endif
//TODO #if (HAS_TMS9989)
//TODO 	CPU_TMS9989,
//TODO #endif
//TODO #if (HAS_TMS9995)
//TODO 	CPU_TMS9995,
//TODO #endif
//TODO #if (HAS_TMS99105A)
//TODO 	CPU_TMS99105A,
//TODO #endif
//TODO #if (HAS_TMS99110A)
//TODO 	CPU_TMS99110A,
//TODO #endif
//TODO #if (HAS_Z8000)
//TODO 	CPU_Z8000,
//TODO #endif
//TODO #if (HAS_TMS32010)
//TODO 	CPU_TMS32010,
//TODO #endif
//TODO #if (HAS_TMS32025)
//TODO 	CPU_TMS32025,
//TODO #endif
//TODO #if (HAS_TMS32031)
//TODO 	CPU_TMS32031,
//TODO #endif
//TODO #if (HAS_CCPU)
//TODO 	CPU_CCPU,
//TODO #endif
//TODO #if (HAS_ADSP2100)
//TODO 	CPU_ADSP2100,
//TODO #endif
//TODO #if (HAS_ADSP2101)
//TODO  CPU_ADSP2101,
//TODO #endif
//TODO #if (HAS_ADSP2105)
//TODO 	CPU_ADSP2105,
//TODO #endif
//TODO #if (HAS_ADSP2115)
//TODO 	CPU_ADSP2115,
//TODO #endif
//TODO #if (HAS_PSXCPU)
//TODO 	CPU_PSXCPU,
//TODO #endif
//TODO #if (HAS_ASAP)
//TODO 	CPU_ASAP,
//TODO #endif
//TODO #if (HAS_UPD7810)
//TODO 	CPU_UPD7810,
//TODO #endif
//TODO #if (HAS_UPD7807)
//TODO 	CPU_UPD7807,
//TODO #endif
//TODO #if (HAS_JAGUAR)
//TODO 	CPU_JAGUARGPU,
//TODO 	CPU_JAGUARDSP,
//TODO #endif
//TODO #if (HAS_R3000)
//TODO 	CPU_R3000BE,
//TODO 	CPU_R3000LE,
//TODO #endif
//TODO #if (HAS_R4600)
//TODO 	CPU_R4600BE,
//TODO 	CPU_R4600LE,
//TODO #endif
//TODO #if (HAS_R5000)
//TODO 	CPU_R5000BE,
//TODO 	CPU_R5000LE,
//TODO #endif
//TODO #if (HAS_ARM)
//TODO 	CPU_ARM,
//TODO #endif
//TODO #if (HAS_SH2)
//TODO 	CPU_SH2,
//TODO #endif
//TODO #if (HAS_DSP32C)
//TODO 	CPU_DSP32C,
//TODO #endif
//TODO #if (HAS_PIC16C54)
//TODO 	CPU_PIC16C54,
//TODO #endif
//TODO #if (HAS_PIC16C55)
//TODO 	CPU_PIC16C55,
//TODO #endif
//TODO #if (HAS_PIC16C56)
//TODO 	CPU_PIC16C56,
//TODO #endif
//TODO #if (HAS_PIC16C57)
//TODO 	CPU_PIC16C57,
//TODO #endif
//TODO #if (HAS_PIC16C58)
//TODO 	CPU_PIC16C58,
//TODO #endif
//TODO 
//TODO #ifdef MESS
//TODO #if (HAS_APEXC)
//TODO 	CPU_APEXC,
//TODO #endif
//TODO #if (HAS_CDP1802)
//TODO 	CPU_CDP1802,
//TODO #endif
//TODO #if (HAS_CP1600)
//TODO 	CPU_CP1600,
//TODO #endif
//TODO #if (HAS_F8)
//TODO 	CPU_F8,
//TODO #endif
//TODO #if (HAS_G65816)
//TODO 	CPU_G65816,
//TODO #endif
//TODO #if (HAS_LH5801)
//TODO 	CPU_LH5801,
//TODO #endif
//TODO #if (HAS_PDP1)
//TODO 	CPU_PDP1,
//TODO #endif
//TODO #if (HAS_SATURN)
//TODO 	CPU_SATURN,
//TODO #endif
//TODO #if (HAS_SC61860)
//TODO 	CPU_SC61860,
//TODO #endif
//TODO #if (HAS_SPC700)
//TODO 	CPU_SPC700,
//TODO #endif
//TODO #if (HAS_Z80GB)
//TODO 	CPU_Z80GB,
//TODO #endif
//TODO #if (HAS_Z80_MSX)
//TODO 	CPU_Z80_MSX,
//TODO #endif
//TODO #endif
//TODO     CPU_COUNT
//TODO };
//TODO 
//TODO 
//TODO 
//TODO /*************************************
//TODO  *
//TODO  *	Interrupt line constants
//TODO  *
//TODO  *************************************/
//TODO 
//TODO enum
//TODO {
//TODO 	/* line states */
//TODO 	CLEAR_LINE = 0,				/* clear (a fired, held or pulsed) line */
//TODO 	ASSERT_LINE,				/* assert an interrupt immediately */
//TODO 	HOLD_LINE,					/* hold interrupt line until acknowledged */
//TODO 	PULSE_LINE,					/* pulse interrupt line for one instruction */
//TODO 
//TODO 	/* internal flags (not for use by drivers!) */
//TODO 	INTERNAL_CLEAR_LINE = 100 + CLEAR_LINE,
//TODO 	INTERNAL_ASSERT_LINE = 100 + ASSERT_LINE,
//TODO 
//TODO 	/* interrupt parameters */
//TODO 	MAX_IRQ_LINES =	16,			/* maximum number of IRQ lines per CPU */
//TODO 	IRQ_LINE_NMI = 127			/* IRQ line for NMIs */
//TODO };
//TODO 
//TODO 
//TODO 
//TODO /*************************************
//TODO  *
//TODO  *	CPU information constants
//TODO  *
//TODO  *************************************/
//TODO 
//TODO /* get_reg/set_reg constants */
//TODO enum
//TODO {
//TODO 	MAX_REGS = 128,				/* maximum number of register of any CPU */
//TODO 
//TODO 	/* This value is passed to activecpu_get_reg to retrieve the previous
//TODO 	 * program counter value, ie. before a CPU emulation started
//TODO 	 * to fetch opcodes and arguments for the current instrution. */
//TODO 	REG_PREVIOUSPC = -1,
//TODO 
//TODO 	/* This value is passed to activecpu_get_reg to retrieve the current
//TODO 	 * program counter value. */
//TODO 	REG_PC = -2,
//TODO 
//TODO 	/* This value is passed to activecpu_get_reg to retrieve the current
//TODO 	 * stack pointer value. */
//TODO 	REG_SP = -3,
//TODO 
//TODO 	/* This value is passed to activecpu_get_reg/activecpu_set_reg, instead of one of
//TODO 	 * the names from the enum a CPU core defines for it's registers,
//TODO 	 * to get or set the contents of the memory pointed to by a stack pointer.
//TODO 	 * You can specify the n'th element on the stack by (REG_SP_CONTENTS-n),
//TODO 	 * ie. lower negative values. The actual element size (UINT16 or UINT32)
//TODO 	 * depends on the CPU core. */
//TODO 	REG_SP_CONTENTS = -4
//TODO };
//TODO 
//TODO 
//TODO /* endianness constants */
//TODO enum
//TODO {
//TODO 	CPU_IS_LE = 0,				/* emulated CPU is little endian */
//TODO 	CPU_IS_BE					/* emulated CPU is big endian */
//TODO };
//TODO 
//TODO 
//TODO /* Values passed to the cpu_info function of a core to retrieve information */
//TODO enum
//TODO {
//TODO 	CPU_INFO_REG,
//TODO 	CPU_INFO_FLAGS = MAX_REGS,
//TODO 	CPU_INFO_NAME,
//TODO 	CPU_INFO_FAMILY,
//TODO 	CPU_INFO_VERSION,
//TODO 	CPU_INFO_FILE,
//TODO 	CPU_INFO_CREDITS,
//TODO 	CPU_INFO_REG_LAYOUT,
//TODO 	CPU_INFO_WIN_LAYOUT
//TODO };
//TODO 
//TODO 
//TODO 
//TODO /*************************************
//TODO  *
//TODO  *	Core CPU interface structure
//TODO  *
//TODO  *************************************/
//TODO 
//TODO struct cpu_interface
//TODO {
//TODO 	/* index (used to make sure we mach the enum above */
//TODO 	unsigned	cpu_num;
//TODO 
//TODO 	/* table of core functions */
//TODO 	void		(*init)(void);
//TODO 	void		(*reset)(void *param);
//TODO 	void		(*exit)(void);
//TODO 	int			(*execute)(int cycles);
//TODO 	void		(*burn)(int cycles);
//TODO 	unsigned	(*get_context)(void *reg);
//TODO 	void		(*set_context)(void *reg);
//TODO 	const void *(*get_cycle_table)(int which);
//TODO 	void		(*set_cycle_table)(int which, void *new_table);
//TODO 	unsigned	(*get_reg)(int regnum);
//TODO 	void		(*set_reg)(int regnum, unsigned val);
//TODO 	void		(*set_irq_line)(int irqline, int linestate);
//TODO 	void		(*set_irq_callback)(int(*callback)(int irqline));
//TODO 	const char *(*cpu_info)(void *context,int regnum);
//TODO 	unsigned	(*cpu_dasm)(char *buffer,unsigned pc);
//TODO 
//TODO 	/* IRQ and clock information */
//TODO 	unsigned	num_irqs;
//TODO 	int			default_vector;
//TODO 	int *		icount;
//TODO 	double		overclock;
//TODO 
//TODO 	/* memory information */
//TODO 	int			databus_width;
//TODO 	mem_read_handler memory_read;
//TODO 	mem_write_handler memory_write;
//TODO 	mem_read_handler internal_read;
//TODO 	mem_write_handler internal_write;
//TODO 	offs_t		pgm_memory_base;
//TODO 	void		(*set_op_base)(offs_t pc);
//TODO 	int			address_shift;
//TODO 	unsigned	address_bits;
//TODO 	unsigned	endianess;
//TODO 	unsigned	align_unit;
//TODO 	unsigned	max_inst_len;
//TODO };
//TODO 
//TODO 
//TODO 
//TODO /*************************************
//TODO  *
//TODO  *	 Core CPU interface functions
//TODO  *
//TODO  *************************************/
//TODO 
//TODO /* reset the internal CPU tracking */
//TODO int cpuintrf_init(void);
//TODO 
//TODO /* set up the interface for one CPU of a given type */
//TODO int	cpuintrf_init_cpu(int cpunum, int cputype);
//TODO 
//TODO /* clean up the interface for one CPU */
//TODO void cpuintrf_exit_cpu(int cpunum);
//TODO 
//TODO /* remember the previous context and set a new one */
//TODO void cpuintrf_push_context(int cpunum);
//TODO 
//TODO /* restore the previous context */
//TODO void cpuintrf_pop_context(void);
//TODO 
//TODO 
//TODO 
//TODO /*************************************
//TODO  *
//TODO  *	 Active CPU acccessors
//TODO  *
//TODO  *************************************/
//TODO 
//TODO /* apply a +/- to the current icount */
//TODO void activecpu_adjust_icount(int delta);
//TODO 
//TODO /* return the current icount */
//TODO int activecpu_get_icount(void);
//TODO 
//TODO /* ensure banking is reset properly */
//TODO void activecpu_reset_banking(void);
//TODO 
//TODO /* set the IRQ line on a CPU -- drivers use cpu_set_irq_line() */
//TODO void activecpu_set_irq_line(int irqline, int state);
//TODO 
//TODO /* return a pointer to the active cycle count table for the active CPU */
//TODO const void *activecpu_get_cycle_table(int which);
//TODO 
//TODO /* set a pointer to the active cycle count table for the active CPU */
//TODO void activecpu_set_cycle_tbl(int which, void *new_table);
//TODO 
//TODO /* return the value of a register on the active CPU */
//TODO unsigned activecpu_get_reg(int regnum);
//TODO 
//TODO /* set the value of a register on the active CPU */
//TODO void activecpu_set_reg(int regnum, unsigned val);
//TODO 
//TODO /* return the PC, corrected to a byte offset, on the active CPU */
//TODO offs_t activecpu_get_pc_byte(void);
//TODO 
//TODO /* update the banking on the active CPU */
//TODO void activecpu_set_op_base(unsigned val);
//TODO 
//TODO /* disassemble a line at a given PC on the active CPU */
//TODO unsigned activecpu_dasm(char *buffer, unsigned pc);
//TODO 
//TODO /* return a string containing the state of the flags on the active CPU */
//TODO const char *activecpu_flags(void);
//TODO 
//TODO /* return a string containing the value of a register on the active CPU */
//TODO const char *activecpu_dump_reg(int regnum);
//TODO 
//TODO /* return a string containing the state of the active CPU */
//TODO const char *activecpu_dump_state(void);
//TODO 
//TODO /* return the default IRQ vector for the active CPU */
//TODO int activecpu_default_irq_vector(void);
//TODO 
//TODO /* return the width of the address bus on the active CPU */
//TODO unsigned activecpu_address_bits(void);
//TODO 
//TODO /* return the active address mask on the active CPU */
//TODO unsigned activecpu_address_mask(void);
//TODO 
//TODO /* return the shift value to convert from address to bytes on the active CPU */
//TODO int activecpu_address_shift(void);
//TODO 
//TODO /* return the endianess of the active CPU */
//TODO unsigned activecpu_endianess(void);
//TODO 
//TODO /* return the width of the data bus on the active CPU */
//TODO unsigned activecpu_databus_width(void);
//TODO 
//TODO /* return the required alignment of data accesses on the active CPU */
//TODO unsigned activecpu_align_unit(void);
//TODO 
//TODO /* return the maximum length of one instruction on the active CPU */
//TODO unsigned activecpu_max_inst_len(void);
//TODO 
//TODO /* return a string containing the name of the active CPU */
//TODO const char *activecpu_name(void);
//TODO 
//TODO /* return a string containing the family of the active CPU */
//TODO const char *activecpu_core_family(void);
//TODO 
//TODO /* return a string containing the version of the active CPU */
//TODO const char *activecpu_core_version(void);
//TODO 
//TODO /* return a string containing the filename for the emulator of the active CPU */
//TODO const char *activecpu_core_file(void);
//TODO 
//TODO /* return a string containing the emulation credits for the active CPU */
//TODO const char *activecpu_core_credits(void);
//TODO 
//TODO /* return a string containing the registers of the active CPU */
//TODO const char *activecpu_reg_layout(void);
//TODO 
//TODO /* return a string containing the debugger layout of the active CPU */
//TODO const char *activecpu_win_layout(void);
//TODO 
//TODO 
//TODO 
//TODO /*************************************
//TODO  *
//TODO  *	 Specific CPU acccessors
//TODO  *
//TODO  *************************************/
//TODO 
//TODO /* execute the requested cycles on a given CPU */
//TODO int cpunum_execute(int cpunum, int cycles);
//TODO 
//TODO /* signal a reset and set the IRQ ack callback for a given CPU */
//TODO void cpunum_reset(int cpunum, void *param, int (*irqack)(int));
//TODO 
//TODO /* read a byte from another CPU's memory space */
//TODO data8_t cpunum_read_byte(int cpunum, offs_t address);
//TODO 
//TODO /* write a byte from another CPU's memory space */
//TODO void cpunum_write_byte(int cpunum, offs_t address, data8_t data);
//TODO 
//TODO /* return a pointer to the saved context of a given CPU, or NULL if the
//TODO    context is active (and contained within the CPU core */
//TODO void *cpunum_get_context_ptr(int cpunum);
//TODO 
//TODO /* return a pointer to the active cycle count table for a given CPU */
//TODO const void *cpunum_get_cycle_table(int cpunum, int which);
//TODO 
//TODO /* set a pointer to the active cycle count table for a given CPU */
//TODO void cpunum_set_cycle_tbl(int cpunum, int which, void *new_table);
//TODO 
//TODO /* return the value of a register on a given CPU */
//TODO unsigned cpunum_get_reg(int cpunum, int regnum);
//TODO 
//TODO /* set the value of a register on a given CPU */
//TODO void cpunum_set_reg(int cpunum, int regnum, unsigned val);
//TODO 
//TODO /* return the PC, corrected to a byte offset, on a given CPU */
//TODO offs_t cpunum_get_pc_byte(int cpunum);
//TODO 
//TODO /* update the banking on a given CPU */
//TODO void cpunum_set_op_base(int cpunum, unsigned val);
//TODO 
//TODO /* disassemble a line at a given PC on a given CPU */
//TODO unsigned cpunum_dasm(int cpunum, char *buffer, unsigned pc);
//TODO 
//TODO /* return a string containing the state of the flags on a given CPU */
//TODO const char *cpunum_flags(int cpunum);
//TODO 
//TODO /* return a string containing the value of a register on a given CPU */
//TODO const char *cpunum_dump_reg(int cpunum, int regnum);
//TODO 
//TODO /* return a string containing the state of a given CPU */
//TODO const char *cpunum_dump_state(int cpunum);
//TODO 
//TODO /* return the default IRQ vector for a given CPU */
//TODO int cpunum_default_irq_vector(int cpunum);
//TODO 
//TODO /* return the width of the address bus on a given CPU */
//TODO unsigned cpunum_address_bits(int cpunum);
//TODO 
//TODO /* return the active address mask on a given CPU */
//TODO unsigned cpunum_address_mask(int cpunum);
//TODO 
//TODO /* return the shift value to convert from address to bytes on a given CPU */
//TODO int cpunum_address_shift(int cpunum);
//TODO 
//TODO /* return the endianess of a given CPU */
//TODO unsigned cpunum_endianess(int cpunum);
//TODO 
//TODO /* return the width of the data bus on a given CPU */
//TODO unsigned cpunum_databus_width(int cpunum);
//TODO 
//TODO /* return the required alignment of data accesses on a given CPU */
//TODO unsigned cpunum_align_unit(int cpunum);
//TODO 
//TODO /* return the maximum length of one instruction on a given CPU */
//TODO unsigned cpunum_max_inst_len(int cpunum);
//TODO 
//TODO /* return a string containing the name of a given CPU */
//TODO const char *cpunum_name(int cpunum);
//TODO 
//TODO /* return a string containing the family of a given CPU */
//TODO const char *cpunum_core_family(int cpunum);
//TODO 
//TODO /* return a string containing the version of a given CPU */
//TODO const char *cpunum_core_version(int cpunum);
//TODO 
//TODO /* return a string containing the filename for the emulator of a given CPU */
//TODO const char *cpunum_core_file(int cpunum);
//TODO 
//TODO /* return a string containing the emulation credits for a given CPU */
//TODO const char *cpunum_core_credits(int cpunum);
//TODO 
//TODO /* return a string containing the registers of a given CPU */
//TODO const char *cpunum_reg_layout(int cpunum);
//TODO 
//TODO /* return a string containing the debugger layout of a given CPU */
//TODO const char *cpunum_win_layout(int cpunum);
//TODO 
//TODO 
//TODO 
//TODO /*************************************
//TODO  *
//TODO  *	 CPU type acccessors
//TODO  *
//TODO  *************************************/
//TODO 
//TODO /* return the default IRQ vector for a given CPU type */
//TODO int cputype_default_irq_vector(int cputype);
//TODO 
//TODO /* return the width of the address bus on a given CPU type */
//TODO unsigned cputype_address_bits(int cputype);
//TODO 
//TODO /* return the active address mask on a given CPU type */
//TODO unsigned cputype_address_mask(int cputype);
//TODO 
//TODO /* return the shift value to convert from address to bytes on a given CPU type */
//TODO int cputype_address_shift(int cputype);
//TODO 
//TODO /* return the endianess of a given CPU type */
//TODO unsigned cputype_endianess(int cputype);
//TODO 
//TODO /* return the width of the data bus on a given CPU type */
//TODO unsigned cputype_databus_width(int cputype);
//TODO 
//TODO /* return the required alignment of data accesses on a given CPU type */
//TODO unsigned cputype_align_unit(int cputype);
//TODO 
//TODO /* return the maximum length of one instruction on a given CPU type */
//TODO unsigned cputype_max_inst_len(int cputype);
//TODO 
//TODO /* return a string containing the name of a given CPU type */
//TODO const char *cputype_name(int cputype);
//TODO 
//TODO /* return a string containing the family of a given CPU type */
//TODO const char *cputype_core_family(int cputype);
//TODO 
//TODO /* return a string containing the version of a given CPU type */
//TODO const char *cputype_core_version(int cputype);
//TODO 
//TODO /* return a string containing the filename for the emulator of a given CPU type */
//TODO const char *cputype_core_file(int cputype);
//TODO 
//TODO /* return a string containing the emulation credits for a given CPU type */
//TODO const char *cputype_core_credits(int cputype);
//TODO 
//TODO /* return a string containing the registers of a given CPU type */
//TODO const char *cputype_reg_layout(int cputype);
//TODO 
//TODO /* return a string containing the debugger layout of a given CPU type */
//TODO const char *cputype_win_layout(int cputype);
//TODO 
//TODO 
//TODO 
//TODO /*************************************
//TODO  *
//TODO  *	 Miscellaneous functions
//TODO  *
//TODO  *************************************/
//TODO 
//TODO /* dump the states of all CPUs */
//TODO void cpu_dump_states(void);
//TODO 
//TODO /* set a callback function for reset on the 68k */
//TODO void cpu_set_m68k_reset(int cpunum, void (*resetfn)(void));
//TODO 
//TODO 
//TODO 
//TODO /*************************************
//TODO  *
//TODO  *	 Macros
//TODO  *
//TODO  *************************************/
//TODO 
//TODO #define		activecpu_get_previouspc()	activecpu_get_reg(REG_PREVIOUSPC)
//TODO #define		activecpu_get_pc()			activecpu_get_reg(REG_PC)
//TODO #define		activecpu_get_sp()			activecpu_get_reg(REG_SP)
//TODO #define		activecpu_set_pc(val)		activecpu_set_reg(REG_PC, val)
//TODO #define		activecpu_set_sp(val)		activecpu_set_reg(REG_SP, val)
//TODO 
//TODO #define		cpunum_get_previouspc(cpu)	cpunum_get_reg(cpu, REG_PREVIOUSPC)
//TODO #define		cpunum_get_pc(cpu)			cpunum_get_reg(cpu, REG_PC)
//TODO #define		cpunum_get_sp(cpu)			cpunum_get_reg(cpu, REG_SP)
//TODO #define		cpunum_set_pc(cpu, val)		cpunum_set_reg(cpu, REG_PC, val)
//TODO #define		cpunum_set_sp(cpu, val)		cpunum_set_reg(cpu, REG_SP, val)
//TODO 
//TODO /* this is kind of gross - is it necessary */
//TODO #define 	cpu_geturnpc() 				activecpu_get_reg(REG_SP_CONTENTS)
//TODO 
//TODO 
//TODO 
//TODO /*************************************
//TODO  *
//TODO  *	 CPU interface accessors
//TODO  *
//TODO  *************************************/
//TODO 
//TODO /* return a pointer to the interface struct for a given CPU type */
//TODO INLINE const struct cpu_interface *cputype_get_interface(int cputype)
//TODO {
//TODO 	extern const struct cpu_interface cpuintrf[];
//TODO 	return &cpuintrf[cputype];
//TODO }
//TODO 
//TODO 
//TODO /* return a the index of the active CPU */
//TODO INLINE int cpu_getactivecpu(void)
//TODO {
//TODO 	extern int activecpu;
//TODO 	return activecpu;
//TODO }
//TODO 
//TODO 
//TODO /* return a the total number of registered CPUs */
//TODO INLINE int cpu_gettotalcpu(void)
//TODO {
//TODO 	extern int totalcpu;
//TODO 	return totalcpu;
//TODO }
//TODO 
//TODO 
//TODO 
//TODO #ifdef __cplusplus
//TODO }
//TODO #endif
//TODO 
//TODO #endif	/* CPUINTRF_H */
//TODO 
//TODO     
}
